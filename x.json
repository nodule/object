{
  "name": "object",
  "description": "Object nodes for Chiχ",
  "version": "0.0.2",
  "repository": {
    "type": "git",
    "url": "https://github.com/nodule/object.git"
  },
  "dependencies": {
    "underscore": "1.x.x",
    "instance-of": "1.x.x",
    "dot-object": "0.x.x"
  },
  "nodes": [
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Cloning object"
      },
      "description": "Create a shallow-copied clone of the object. Any nested objects or arrays will be copied by reference, not duplicated.",
      "ns": "object",
      "name": "clone",
      "fn": "output.out = underscore.clone(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Creating object"
      },
      "description": "Create an object, if input is a direct object it just returns a copy of the object",
      "ns": "object",
      "name": "create",
      "fn": "output.out = input.in;\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "defaults": {
            "title": "Defaults",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Applying defaults to object"
      },
      "description": "Fill in undefined properties in object with values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.",
      "ns": "object",
      "name": "defaults",
      "fn": "output.out = underscore.defaults(input. in , input.defaults)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Extending object"
      },
      "description": "Output a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys)",
      "ns": "object",
      "name": "extend",
      "fn": "output.out = underscore.extend(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Value(s)",
            "type": "array"
          },
          "keys": {
            "title": "Key(s)",
            "type": "array"
          },
          "object": {
            "title": "Object",
            "type": "object",
            "default": null
          }
        },
        "output": {
          "error": {
            "title": "Error",
            "type": "object"
          },
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Filling object"
      },
      "description": "Fills an object with key/value pairs. Both key and in are array ports. Key must be fed the key names, and in will contain the values.",
      "ns": "object",
      "name": "fill",
      "fn": "var obj = input.object ? input.object : {};\n\nif(input.keys.length !== input.in.length) {\n  output.error = {\n    msg: 'Key length does not match value length'\n  };\n} else {\n\n  for(var i = 0; i < input.keys.length; i++) {\n   obj[input.keys[i]] = input.in[i];\n  }\n\n  output.out = obj;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "any"
          },
          "xin": {
            "title": "In Group",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "group": "result",
            "type": "any"
          },
          "xout": {
            "title": "Xout",
            "type": "array"
          }
        }
      },
      "expose": [
        "chi"
      ],
      "phrases": {
        "active": "Grouping object"
      },
      "description": "Groups input into an array",
      "async": true,
      "ns": "object",
      "name": "group",
      "fn": "on.input. in = function () {\n  // x contains our keys\n  for (var gid in x) {\n\n    state[gid].items.push(data);\n\n    if (state[gid].complete &&\n      state[gid].total === (state[gid].items.length)) {\n\n      var g = chi.group('xout', output);\n      output({\n        out: state[gid].items\n      }, g.item());\n\n      g.done();\n\n      delete state[gid];\n\n    }\n\n  }\n};\n\non.input.xin = function () {\n  if (!data.complete) {\n    state[data.gid] = {\n      items: [],\n      total: null,\n      complete: false\n    };\n  } else {\n    state[data.gid].total = data.items.length;\n    state[data.gid].complete = true;\n\n    // ok sometimes at this point we already have everything...\n    // I wonder if the function stays in scope, i think not.\n    if (state[data.gid].complete &&\n      state[data.gid].total === (state[data.gid].items.length)) {\n\n      var g = chi.group('xout', output);\n      output({\n        out: state[data.gid].items\n      }, g.item());\n\n      g.done();\n\n      delete state[data.gid];\n\n    }\n  }\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "any"
          },
          "xin": {
            "title": "In Group",
            "type": "any"
          },
          "by": {
            "title": "Group By",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "group": "result",
            "type": "boolean"
          },
          "by": {
            "title": "Group By",
            "group": "result",
            "type": "any"
          },
          "xout": {
            "title": "Xout",
            "type": "array"
          }
        }
      },
      "expose": [
        "chi"
      ],
      "phrases": {
        "active": "Grouping object"
      },
      "description": "Groups an object by it's differentiator",
      "async": true,
      "ns": "object",
      "name": "groupBy",
      "fn": "state = {\n  group: {},\n  total: 0\n};\n\n// If this even works, state is not cleared\n// properly or at lease during send out\n// the current groups can be removed.\n\n// really needs a main also.\n// main is called always then.\n// and check the existance of those keys\n// first just make the synchronous one\non.input. in = function () {\n  // x contains our keys\n  var id = x[state.gid];\n  if (!state[id]) state[id] = {};\n\n  state[id]. in = data;\n\n  if (state[id].by) {\n    // we have a match.\n    if (!state.group[state[id].by]) state.group[state[id].by] = [];\n    state.group[state[id].by].push(state[id]. in );\n  }\n\n  state.total++;\n\n  if (state.complete && state.l === (state.total / 2)) {\n    // send them out, might also create groups again.\n    for (var key in state.group) {\n      var g = chi.group('xout', output);\n\n      // like to introduce the grouped output, output like the below is grouped\n      // it's a bit like an array port, only difference the output goes to normal ports.\n      // I would like to add the convention, that if you send output this way.\n      // You must declare a group inside the json\n      //\n      // out: \"group\": \"result\"\n      // by:  \"group\": \"result\"\n      //\n      // in a ui this will look like:\n      // [o o] o o o\n      //\n      // Only two states:\n      //\n      //  [• •] and [o o]\n      //\n      // Whereas the individual ports are not perse synchronous:\n      //\n      //  [o o] o • o\n      //\n      // Where the first is the grouped output, you are assured those ports\n      // are pairs of data comming out, belong to eachother.\n      output({\n        out: state.group[key],\n        by: JSON.parse(key) // same as input.by\n      }, g.item());\n      g.done();\n    }\n  }\n};\n\n// collect the keys.\non.input.by = function () {\n\n  var id = x[state.gid];\n  if (!state[id]) state[id] = {};\n\n  state[id].by = JSON.stringify(data); // keyify\n\n  if (state[id]. in ) {\n    // we have a match.\n    if (!state.group[state[id].by]) state.group[state[id].by] = [];\n    state.group[state[id].by].push(state[id]. in );\n  }\n\n  state.total++;\n\n  if (state.complete && state.l === (state.total / 2)) {\n    // send them out, might also create groups again.\n    for (var key in state.group) {\n      var g = chi.group('xout', output);\n      output({\n        out: state.group[key],\n        by: JSON.parse(key) // same as input.by\n      }, g.item());\n      g.done();\n    }\n  }\n\n};\n\n// xin now kinda acts like a main.\n// more clear would probably be group begin and end methods.\n// it also makes it required to have this connected.\non.input.xin = function () {\n  // will always arrive first.\n  // probably this can all be done outside a component.\n  // the pair matching is something common.\n  if (!data.complete) {\n    // register the groupId\n    // we rely on this being set first\n    state.gid = data.gid;\n    state.complete = false;\n  } else {\n    // is finished\n    // send it out.\n    state.complete = true;\n    state.l = data.items.length;\n  }\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object",
            "async": true
          },
          "path": {
            "title": "Path",
            "type": "string"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "object"
          }
        }
      },
      "require": {
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether the object has property {{input.path}}"
      },
      "description": "Does the object contain the given property? You can use dot notation to dig deeper into the object.",
      "async": true,
      "ns": "object",
      "name": "has",
      "fn": "on.input.in = function() {\n  // can be data or input.in\n  if(dot_object().pick(data, input.path)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Inverting object"
      },
      "description": "Retrieves a copy of the object where the keys have become the values and the values the keys. For this to work, all of your object's values should be unique and string serializable",
      "ns": "object",
      "name": "invert",
      "fn": "output.out = underscore.invert(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "kind": {
            "title": "Type",
            "type": "string"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "any"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "instance-of": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a {{input.type}}"
      },
      "description": "Determines if object an object is of a certain type",
      "async": true,
      "ns": "object",
      "name": "is",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (instance_of(val, input.kind)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining Arguments Object"
      },
      "description": "Determines if object is an Arguments Object",
      "ns": "object",
      "name": "isArguments",
      "fn": "if (underscore.isArguments(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "array"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining Array"
      },
      "description": "Determines if object is an Array",
      "async": true,
      "ns": "object",
      "name": "isArray",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isArray(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a boolean"
      },
      "description": "Determines if object is a Boolean",
      "async": true,
      "ns": "object",
      "name": "isBoolean",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isBoolean(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "date"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a Date"
      },
      "description": "Determines if object is a Date",
      "async": true,
      "ns": "object",
      "name": "isDate",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isDate(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "DomElement"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining dom element"
      },
      "description": "Determines if object is a DOM element.",
      "async": true,
      "ns": "object",
      "name": "isElement",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isElement(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining empty object"
      },
      "description": "Determines if object contains no values (no enumerable own-properties)",
      "async": true,
      "ns": "object",
      "name": "isEmpty",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isEmpty(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "other": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining equality"
      },
      "description": "Performs an optimized deep comparison between the two objects, to determine if they should be considered equal.",
      "ns": "object",
      "name": "isEqual",
      "fn": "if (underscore.isEqual(input.in, input.other)) {\n  output.yes = input.in;\n} else {\n  output.no = [input.in,input.other];\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "number"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a finite number"
      },
      "description": "Determines if object is a Finite Number",
      "async": true,
      "ns": "object",
      "name": "isFinite",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isFinite(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "function"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a function"
      },
      "description": "Determines if object is a Function",
      "async": true,
      "ns": "object",
      "name": "isFunction",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isFunction(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "NaN"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is NaN"
      },
      "description": "Determines if object is NaN",
      "async": true,
      "ns": "object",
      "name": "isNaN",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isNaN(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "null"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is Null"
      },
      "description": "Determines if object is Null",
      "async": true,
      "ns": "object",
      "name": "isNull",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isNull(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "number"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a number"
      },
      "description": "Determines if object is a Number",
      "ns": "object",
      "name": "isNumber",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isNumber(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining Object"
      },
      "description": "Determines if object is an Object",
      "async": true,
      "ns": "object",
      "name": "isObject",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isObject(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "RegExp"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a RegExp"
      },
      "description": "Determines if object is a RegExp",
      "async": true,
      "ns": "object",
      "name": "isRegExp",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isRegExp(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "string"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a string"
      },
      "description": "Determines if object is a String",
      "async": true,
      "ns": "object",
      "name": "isString",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isString(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "any"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Determining whether object is undefined"
      },
      "description": "Determines if object is Undefined",
      "async": true,
      "ns": "object",
      "name": "isUndefined",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n\n  if (underscore.isUndefined(val)) {\n    output({ yes: data });\n  } else {\n    output({ no: data });\n  }\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "async": true,
            "type": "object"
          },
          "path": {
            "title": "Path",
            "type": "string",
            "default": null
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x",
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Retrieving object properties"
      },
      "description": "Retrieve all the names of the object's properties",
      "async": true,
      "ns": "object",
      "name": "keys",
      "fn": "on.input.in = function() {\n  var val = input.path ? dot_object().pick(input.path, data) : data;\n  output( { out: underscore.keys(val) } );\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining methods"
      },
      "description": "Gets a sorted list of the names of every method in an object — that is to say, the name of every function property of the object",
      "ns": "object",
      "name": "methods",
      "fn": "output.out = underscore.methods(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Input Object",
            "type": "object"
          },
          "from": {
            "title": "From",
            "type": "array"
          },
          "to": {
            "title": "To",
            "type": "array"
          }
        },
        "output": {
          "error": {
            "title": "Error",
            "type": "object"
          },
          "out": {
            "title": "Output",
            "type": "object"
          }
        }
      },
      "require": {
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Moving object properties"
      },
      "description": "Moves properties within one object from one place to the other",
      "ns": "object",
      "name": "move",
      "fn": "// Receiving an array, check both are of the same length.\nif(input.from.length !== input.to.length) {\n  output.error = new Error('from length does not match to length');\n} else {\n\n  var doo = dot_object();\n  for(var i = 0; i < input.from.length; i++) {\n    doo.move(input.from[i], input.to[i], input.in);\n  }\n\n  output.out = input.in;\n\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "omit": {
            "title": "Pick",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Omitting object keys"
      },
      "description": "Return a copy of the object, filtered to omit the blacklisted keys (or array of keys)",
      "ns": "object",
      "name": "omit",
      "fn": "output.out = underscore.omit(input. in , input.omit)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "async": true,
            "type": "Object"
          },
          "match": {
            "title": "Path",
            "type": "array"
          }
        },
        "output": {
          "out": {
            "title": "Output",
            "type": "any"
          },
          "error": {
            "title": "Error",
            "type": "object"
          }
        }
      },
      "require": {
        "dot-object": "0.x.x"
      },
      "phrases": {
        "active": "Picking one of the properties"
      },
      "description": "Selects a (nested) property outputing the first property available. data.in || data.that || .. etc. Sends an error of none of the properties matched.",
      "async": true,
      "ns": "object",
      "name": "oneOf",
      "fn": "on.input.in = function() {\n\n  var val;\n  for(var i = 0; i < input.path.length; i++) {\n    val = dot_object().pick(input.path[i], data);\n    if(val !== undefined) {\n      output({ out: val });\n      break;\n    }\n  }\n\n  output({ error: new Error('None of the properties are found') });\n\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Transforming object to pairs"
      },
      "description": "Retrieve key value pairs from an object",
      "ns": "object",
      "name": "pairs",
      "fn": "output.out = underscore.pairs(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "pick": {
            "title": "Pick",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Picking object"
      },
      "description": "Output a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys)",
      "ns": "object",
      "name": "pick",
      "fn": "output.out = underscore.pick(input. in , input.pick)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Value",
            "type": "any"
          },
          "key": {
            "title": "Key",
            "type": "string"
          },
          "object": {
            "title": "Object",
            "type": "object",
            "default": null
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Setting property {{input.key}}"
      },
      "description": "Set a property on an object, or else create a new object and set the property",
      "ns": "object",
      "name": "set",
      "fn": "var obj = input.object ? input.object : {};\nobj[input.key] = input. in ;\noutput.out = obj;\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Retrieving object values"
      },
      "description": "Retrieve all of the values of the object's properties",
      "ns": "object",
      "name": "values",
      "fn": "output.out = underscore.values(input. in )\n"
    }
  ],
  "twigs": []
}