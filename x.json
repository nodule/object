{
  "name": "object",
  "description": "Object nodes for Chiχ",
  "version": "0.0.2",
  "repository": {
    "type": "git",
    "url": "https://github.com/nodule/object.git"
  },
  "dependencies": {
    "underscore": "1.x.x",
    "instance-of": "1.x.x"
  },
  "nodes": [
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Cloning object"
      },
      "description": "Create a shallow-copied clone of the object. Any nested objects or arrays will be copied by reference, not duplicated.",
      "ns": "object",
      "name": "clone",
      "fn": "output.out = underscore.clone(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Creating object"
      },
      "description": "Create an object, if input is a direct object it just returns a copy of the object",
      "ns": "object",
      "name": "create",
      "fn": "output.out = input.in;\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "defaults": {
            "title": "Defaults",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Applying defaults to object"
      },
      "description": "Fill in undefined properties in object with values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.",
      "ns": "object",
      "name": "defaults",
      "fn": "output.out = underscore.defaults(input. in , input.defaults)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Extending object"
      },
      "description": "Output a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys)",
      "ns": "object",
      "name": "extend",
      "fn": "output.out = underscore.extend(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Value(s)",
            "type": "array"
          },
          "keys": {
            "title": "Key(s)",
            "type": "array"
          },
          "object": {
            "title": "Object",
            "type": "object",
            "default": null
          }
        },
        "output": {
          "error": {
            "title": "Error",
            "type": "object"
          },
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Filling object"
      },
      "description": "Fills an object with key/value pairs. Both key and in are array ports. Key must be fed the key names, and in will contain the values.",
      "ns": "object",
      "name": "fill",
      "fn": "var obj = input.object ? input.object : {};\n\nif(input.keys.length !== input.in.length) {\n  output.error = {\n    msg: 'Key length does not match value length'\n  };\n} else {\n\n  for(var i = 0; i < input.keys.length; i++) {\n   obj[input.keys[i]] = input.in[i];\n  }\n\n  output.out = obj;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "any"
          },
          "xin": {
            "title": "In Group",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "group": "result",
            "type": "any"
          },
          "xout": {
            "title": "Xout",
            "type": "array"
          }
        }
      },
      "expose": [
        "chi"
      ],
      "phrases": {
        "active": "Grouping object"
      },
      "description": "Groups input into an array",
      "async": true,
      "ns": "object",
      "name": "group",
      "fn": "on.input. in = function () {\n  // x contains our keys\n  for (var gid in x) {\n\n    state[gid].items.push(data);\n\n    if (state[gid].complete &&\n      state[gid].total === (state[gid].items.length)) {\n\n      var g = chi.group('xout', output);\n      output({\n        out: state[gid].items\n      }, g.item());\n\n      g.done();\n\n      delete state[gid];\n\n    }\n\n  }\n};\n\non.input.xin = function () {\n  if (!data.complete) {\n    state[data.gid] = {\n      items: [],\n      total: null,\n      complete: false\n    };\n  } else {\n    state[data.gid].total = data.items.length;\n    state[data.gid].complete = true;\n\n    // ok sometimes at this point we already have everything...\n    // I wonder if the function stays in scope, i think not.\n    if (state[data.gid].complete &&\n      state[data.gid].total === (state[data.gid].items.length)) {\n\n      var g = chi.group('xout', output);\n      output({\n        out: state[data.gid].items\n      }, g.item());\n\n      g.done();\n\n      delete state[data.gid];\n\n    }\n  }\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "any"
          },
          "xin": {
            "title": "In Group",
            "type": "any"
          },
          "by": {
            "title": "Group By",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "group": "result",
            "type": "boolean"
          },
          "by": {
            "title": "Group By",
            "group": "result",
            "type": "any"
          },
          "xout": {
            "title": "Xout",
            "type": "array"
          }
        }
      },
      "expose": [
        "chi"
      ],
      "phrases": {
        "active": "Grouping object"
      },
      "description": "Groups an object by it's differentiator",
      "async": true,
      "ns": "object",
      "name": "groupBy",
      "fn": "state = {\n  group: {},\n  total: 0\n};\n\n// If this even works, state is not cleared\n// properly or at lease during send out\n// the current groups can be removed.\n\n// really needs a main also.\n// main is called always then.\n// and check the existance of those keys\n// first just make the synchronous one\non.input. in = function () {\n  // x contains our keys\n  var id = x[state.gid];\n  if (!state[id]) state[id] = {};\n\n  state[id]. in = data;\n\n  if (state[id].by) {\n    // we have a match.\n    if (!state.group[state[id].by]) state.group[state[id].by] = [];\n    state.group[state[id].by].push(state[id]. in );\n  }\n\n  state.total++;\n\n  if (state.complete && state.l === (state.total / 2)) {\n    // send them out, might also create groups again.\n    for (var key in state.group) {\n      var g = chi.group('xout', output);\n\n      // like to introduce the grouped output, output like the below is grouped\n      // it's a bit like an array port, only difference the output goes to normal ports.\n      // I would like to add the convention, that if you send output this way.\n      // You must declare a group inside the json\n      //\n      // out: \"group\": \"result\"\n      // by:  \"group\": \"result\"\n      //\n      // in a ui this will look like:\n      // [o o] o o o\n      //\n      // Only two states:\n      //\n      //  [• •] and [o o]\n      //\n      // Whereas the individual ports are not perse synchronous:\n      //\n      //  [o o] o • o\n      //\n      // Where the first is the grouped output, you are assured those ports\n      // are pairs of data comming out, belong to eachother.\n      output({\n        out: state.group[key],\n        by: JSON.parse(key) // same as input.by\n      }, g.item());\n      g.done();\n    }\n  }\n};\n\n// collect the keys.\non.input.by = function () {\n\n  var id = x[state.gid];\n  if (!state[id]) state[id] = {};\n\n  state[id].by = JSON.stringify(data); // keyify\n\n  if (state[id]. in ) {\n    // we have a match.\n    if (!state.group[state[id].by]) state.group[state[id].by] = [];\n    state.group[state[id].by].push(state[id]. in );\n  }\n\n  state.total++;\n\n  if (state.complete && state.l === (state.total / 2)) {\n    // send them out, might also create groups again.\n    for (var key in state.group) {\n      var g = chi.group('xout', output);\n      output({\n        out: state.group[key],\n        by: JSON.parse(key) // same as input.by\n      }, g.item());\n      g.done();\n    }\n  }\n\n};\n\n// xin now kinda acts like a main.\n// more clear would probably be group begin and end methods.\n// it also makes it required to have this connected.\non.input.xin = function () {\n  // will always arrive first.\n  // probably this can all be done outside a component.\n  // the pair matching is something common.\n  if (!data.complete) {\n    // register the groupId\n    // we rely on this being set first\n    state.gid = data.gid;\n    state.complete = false;\n  } else {\n    // is finished\n    // send it out.\n    state.complete = true;\n    state.l = data.items.length;\n  }\n};\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "key": {
            "title": "Key",
            "type": "string"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether the object has key {{input.key}}"
      },
      "description": "Does the object contain the given key? Identical to object.hasOwnProperty(key), but uses a safe reference to the hasOwnProperty function, in case it's been overridden accidentally.",
      "ns": "object",
      "name": "has",
      "fn": "if(underscore.has(input.in , input.key)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Inverting object"
      },
      "description": "Retrieves a copy of the object where the keys have become the values and the values the keys. For this to work, all of your object's values should be unique and string serializable",
      "ns": "object",
      "name": "invert",
      "fn": "output.out = underscore.invert(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          },
          "kind": {
            "title": "Type",
            "type": "string"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "any"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "instance-of": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a {{input.type}}"
      },
      "description": "Determines if object an object is of a certain type",
      "ns": "object",
      "name": "is",
      "fn": "if (instance_of(input.in, input.kind)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining Arguments Object"
      },
      "description": "Determines if object is an Arguments Object",
      "ns": "object",
      "name": "isArguments",
      "fn": "if (underscore.isArguments(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "array"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining Array"
      },
      "description": "Determines if object is an Array",
      "ns": "object",
      "name": "isArray",
      "fn": "if (underscore.isArray(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a boolean"
      },
      "description": "Determines if object is a Boolean",
      "ns": "object",
      "name": "isBoolean",
      "fn": "if (underscore.isBoolean(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "date"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a Date"
      },
      "description": "Determines if object is a Date",
      "ns": "object",
      "name": "isDate",
      "fn": "if (underscore.isDate(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "DomElement"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining dom element"
      },
      "description": "Determines if object is a DOM element.",
      "ns": "object",
      "name": "isElement",
      "fn": "if (underscore.isElement(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining empty object"
      },
      "description": "Determines if object contains no values (no enumerable own-properties)",
      "ns": "object",
      "name": "isEmpty",
      "fn": "if (underscore.isEmpty(input.in)) {\n  output.yes = true;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "other": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining equality"
      },
      "description": "Performs an optimized deep comparison between the two objects, to determine if they should be considered equal.",
      "ns": "object",
      "name": "isEqual",
      "fn": "if (underscore.isEqual(input.in, input.other)) {\n  output.yes = input.in;\n} else {\n  output.no = [input.in,input.other];\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "number"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a finite number"
      },
      "description": "Determines if object is a Finite Number",
      "ns": "object",
      "name": "isFinite",
      "fn": "if (underscore.isFinite(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "function"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a function"
      },
      "description": "Determines if object is a Function",
      "ns": "object",
      "name": "isFunction",
      "fn": "if (underscore.isFunction(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "NaN"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is NaN"
      },
      "description": "Determines if object is NaN",
      "ns": "object",
      "name": "isNaN",
      "fn": "if (underscore.isNaN(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "null"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is Null"
      },
      "description": "Determines if object is Null",
      "ns": "object",
      "name": "isNull",
      "fn": "if (underscore.isNull(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "number"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a number"
      },
      "description": "Determines if object is a Number",
      "ns": "object",
      "name": "isNumber",
      "fn": "if (underscore.isNumber(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "object"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining Object"
      },
      "description": "Determines if object is an Object",
      "ns": "object",
      "name": "isObject",
      "fn": "if (underscore.isObject(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "RegExp"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a RegExp"
      },
      "description": "Determines if object is a RegExp",
      "ns": "object",
      "name": "isRegExp",
      "fn": "if (underscore.isRegExp(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "string"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is a string"
      },
      "description": "Determines if object is a String",
      "ns": "object",
      "name": "isString",
      "fn": "if (underscore.isString(input.in)) {\n  output.yes = input.in;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "In",
            "type": "any"
          }
        },
        "output": {
          "yes": {
            "title": "Yes",
            "type": "boolean"
          },
          "no": {
            "title": "No",
            "type": "any"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Determining whether object is undefined"
      },
      "description": "Determines if object is Undefined",
      "ns": "object",
      "name": "isUndefined",
      "fn": "if (underscore.isUndefined(input.in)) {\n  output.yes = true;\n} else {\n  output.no = input.in;\n}\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Retrieving object properties"
      },
      "description": "Retrieve all the names of the object's properties",
      "ns": "object",
      "name": "keys",
      "fn": "output.out = underscore.keys(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Dermining methods"
      },
      "description": "Gets a sorted list of the names of every method in an object — that is to say, the name of every function property of the object",
      "ns": "object",
      "name": "methods",
      "fn": "output.out = underscore.methods(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "omit": {
            "title": "Pick",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Omitting object keys"
      },
      "description": "Return a copy of the object, filtered to omit the blacklisted keys (or array of keys)",
      "ns": "object",
      "name": "omit",
      "fn": "output.out = underscore.omit(input. in , input.omit)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Transforming object to pairs"
      },
      "description": "Retrieve key value pairs from an object",
      "ns": "object",
      "name": "pairs",
      "fn": "output.out = underscore.pairs(input. in )\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          },
          "pick": {
            "title": "Pick",
            "type": "any"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Picking object"
      },
      "description": "Output a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys)",
      "ns": "object",
      "name": "pick",
      "fn": "output.out = underscore.pick(input. in , input.pick)\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Value",
            "type": "any"
          },
          "key": {
            "title": "Key",
            "type": "string"
          },
          "object": {
            "title": "Object",
            "type": "object",
            "default": null
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "object"
          }
        }
      },
      "phrases": {
        "active": "Setting propety {{input.key}}"
      },
      "description": "Set a property on an object, or else create a new object and set the property",
      "ns": "object",
      "name": "set",
      "fn": "var obj = input.object ? input.object : {};\nobj[input.key] = input. in ;\noutput.out = obj;\n"
    },
    {
      "ports": {
        "input": {
          "in": {
            "title": "Object",
            "type": "object"
          }
        },
        "output": {
          "out": {
            "title": "out",
            "type": "array"
          }
        }
      },
      "require": {
        "underscore": "1.x.x"
      },
      "phrases": {
        "active": "Retrieving object values"
      },
      "description": "Retrieve all of the values of the object's properties",
      "ns": "object",
      "name": "values",
      "fn": "output.out = underscore.values(input. in )\n"
    }
  ],
  "twigs": []
}